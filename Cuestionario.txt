¿Qué hace el comando git init y en qué situaciones se utiliza? El comando git init se utiliza para inicializar un nuevo repositorio de Git en un directorio. Esto permite que Git comience a rastrear los cambios realizados en los archivos y a gestionar el historial de versiones.

¿Cuál es la diferencia entre git add y git commit en el flujo de trabajo de Git? qEn el flujo de trabajo de Git, git add se utiliza para añadir cambios al área de preparación, permitiendo seleccionar los cambios que deseas incluir en el próximo commit. Por otro lado, git commit captura esos cambios preparados y los guarda en el historial del repositorio con un mensaje que describe las modificaciones. Básicamente, git add marca los cambios y git commit los guarda de manera permanente en el repositorio. Juntos, estos comandos aseguran un manejo preciso y controlado del historial de versiones del proyecto.


¿Que significa que un archivo este en estado "stage" en Git y como se coloca en este estado? En Git, cuando un archivo está en estado "stage", significa que ha sido marcado para ser incluido en el próximo commit. Para colocar un archivo en este estado, se utiliza el comando git add, que añade los cambios del archivo al área de preparación, permitiendo seleccionar y revisar qué cambios específicos se desean registrar en el historial del repositorio antes de guardarlos de manera permanente.

¿Cuál es la diferencia entre git reset --soft, git reset --mixed y git reset --hard?  
--soft Este comando mueve el puntero HEAD a la confirmación especificada sin alterar el área de preparación ni el directorio de trabajo. Los cambios realizados desde la confirmación especificada se mantienen en el área de preparación, listos para ser confirmados nuevamente. Es útil cuando deseas rehacer un commit sin perder los cambios que se hicieron.
--mixed Este comando, que es la opción predeterminada, mueve el puntero HEAD a la confirmación especificada y restablece el área de preparación a la versión de esa confirmación. Los cambios realizados desde la confirmación especificada no se guardan en el área de preparación, pero se mantienen en el directorio de trabajo. Es útil cuando deseas rehacer un commit y modificar los archivos, pero sin perder los cambios locales.
--hard Este comando mueve el puntero HEAD a la confirmación especificada y restablece tanto el área de preparación como el directorio de trabajo a esa confirmación. Todos los cambios realizados desde la confirmación especificada se pierden definitivamente. Es útil cuando deseas deshacer completamente los cambios locales y volver a un estado anterior del repositorio.


¿Qué es una fusión (merge) en Git y cuáles son los posibles conflictos que pueden ocurrir durante el proceso? En Git, una fusión (merge) es el proceso de integrar cambios de diferentes ramas en una sola rama, generalmente combinando la rama de desarrollo con la rama principal. Este proceso permite que los cambios hechos por varios desarrolladores se integren en un único historial de versiones. Sin embargo, durante una fusión pueden ocurrir conflictos si Git no puede resolver automáticamente las diferencias entre las versiones de los archivos.

Posibles conflictos: 

Modificación en la misma línea: Dos ramas modifican la misma línea de código en un archivo.

Eliminación y modificación: Una rama elimina un archivo mientras que la otra lo modifica.

Creación de archivos diferentes con el mismo nombre: Dos ramas crean diferentes archivos con el mismo nombre en el mismo directorio.

¿Para qué se usa el comando git checkout y cuál es su diferencia con git switch? El comando git checkout se utiliza en Git para cambiar entre ramas, restaurar archivos del historial del repositorio y crear nuevas ramas a partir de un commit específico, ofreciendo versatilidad pero con una sintaxis más compleja. Por otro lado, git switch simplifica el proceso de cambiar entre ramas, enfocándose exclusivamente en este propósito y evitando confusiones con otros usos. En resumen, git checkout es más versátil y complejo, mientras que git switch es más específico y claro para cambiar de ramas.

¿Cómo funciona git pull y en qué se diferencia de git fetch? El comando git pull se utiliza para actualizar el repositorio local con los cambios del repositorio remoto, combinando dos comandos: git fetch y git merge. Primero, descarga los cambios del repositorio remoto (similar a git fetch) y luego los fusiona automáticamente con la rama actual. Por otro lado, git fetch solo descarga los cambios del repositorio remoto sin fusionarlos automáticamente, permitiendo revisar y gestionar manualmente la integración de esos cambios. En resumen, git pull es una combinación de git fetch y git merge, mientras que git fetch solo descarga los cambios sin fusionarlos.

¿Qué ocurre cuando se ejecuta git push y qué problemas pueden surgir si hay cambios en el repositorio remoto? Al ejecutar git push, los cambios locales se envían y se sincronizan con el repositorio remoto, actualizando este último con los commits realizados en la rama local. Si hay cambios en el repositorio remoto que no están presentes en la copia local, pueden surgir problemas de conflicto. En este caso, el git push puede ser rechazado y se requerirá realizar un git pull primero para integrar los cambios remotos en la copia local, resolviendo cualquier conflicto antes de volver a intentar el git push. Esto asegura que el historial del proyecto sea coherente y que se mantenga la integridad de los datos.

¿Cuál es la diferencia entre git clone y git init? Al ejecutar git push, los cambios locales se envían y se sincronizan con el repositorio remoto, actualizando este último con los commits realizados en la rama local. Si hay cambios en el repositorio remoto que no están presentes en la copia local, pueden surgir problemas de conflicto. En este caso, el git push puede ser rechazado y se requerirá realizar un git pull primero para integrar los cambios remotos en la copia local, resolviendo cualquier conflicto antes de volver a intentar el git push. Esto asegura que el historial del proyecto sea coherente y que se mantenga la integridad de los datos.
